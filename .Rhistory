if(Version%in%c("OU_GMRF_v1e")) Data = list( "n_i"=dim(c_ip)[1], "n_b"=nrow(family), "n_t"=length(YearSet), "c_ip"=as.matrix(c_ip), "d_i"=df[,'child_b']-1, "X_ij"=X_ij, "t_i"=t_i-min(t_i), "parent_b"=family[ ,'parent_b']-1, "child_b"=family[ ,'child_b']-1, "dist_b"=family[,'dist_b'])
if(Version%in%c("OU_GMRF_v1g","OU_GMRF_v1f")) {
YearSet = min(t_i):max(t_i)
Data = list( "Options_vec"=options, "n_i"=dim(c_ip)[1], "n_b"=nrow(family), "n_t"=length(YearSet), "c_ip"=as.matrix(c_ip), "d_i"=df[,'child_b']-1, "X_ij"=X, "t_i"=t_i-min(t_i), "parent_b"=family[ ,'parent_b']-1, "child_b"=family[ ,'child_b']-1, "dist_b"=family[,'dist_b']) # d_i and child_b redundant?
}
############### Sanity checks on inputs ##############
# Please add more here
# If any distances are negative or below threshold, fix at lower bound
if( any(Data$dist_b < (max(Data$dist_b,na.rm=TRUE)/1e4),na.rm=TRUE) ) {
Data$dist_b = ifelse( Data$dist_b<(max(Data$dist_b,na.rm=TRUE)/1e4), (max(Data$dist_b,na.rm=TRUE)/1e4), Data$dist_b)
warning("Negative distances fixed to lower bound")
}
# If any covariates are missing
if( any(is.na(Data$X_ij)) ) {
Data$X_ij = ifelse(is.na(Data$X_ij), 0, Data$X_ij)
warning("Missing covariate values: replaced with mean")
}
# Check for Options_vec combos that don't make sense
######################################################
if(Version=="OU_GMRF_v1a") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_mean"=log(1), "Epsiloninput_d"=rnorm(Data$n_b))
if(Version=="OU_GMRF_v1b") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_mean"=log(1), "gamma_j"=rep(0,ncol(Data$X_ij)), "Epsiloninput_d"=rnorm(Data$n_b))
if(Version=="OU_GMRF_v1c") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_mean"=log(1), "gamma_j"=rep(0,ncol(Data$X_ij)), "log_detectrate"=log(0.2), "log_extradetectrate_i"=log(rep(1,Data$n_i)), "Epsiloninput_d"=rnorm(Data$n_b))
if(Version=="OU_GMRF_v1d") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_mean"=log(1), "log_extradetectionSD"=log(1), "gamma_j"=rep(0,ncol(Data$X_ij)), "log_detectrate"=log(0.2), "log_extradetectrate_i"=log(rep(1,Data$n_i)), "Epsiloninput_d"=rnorm(Data$n_b))
if(Version=="OU_GMRF_v1e") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_mean"=log(1), "log_extradetectionSD"=log(1), "rhot"=0, "log_sigmat"=log(1), "gamma_j"=rep(0,ncol(Data$X_ij)), "log_detectrate"=log(0.2), "log_extradetectrate_i"=log(rep(1,Data$n_i)), "Epsiloninput_d"=rnorm(Data$n_b), "Deltainput_t"=rnorm(Data$n_t))
if(Version=="OU_GMRF_v1f") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_theta_sp"=log(1), "log_SD_st"=log(1), "rho_sp"=0, "log_mean"=log(1), "log_extradetectionSD"=log(1), "rhot"=0, "log_sigmat"=log(1), "gamma_j"=rep(0,ncol(Data$X_ij)), "log_detectrate"=log(0.2), "log_extradetectrate_i"=rnorm(Data$n_i,sd=0.01), "Epsiloninput_d"=rnorm(Data$n_b,sd=0.01), "Deltainput_t"=rnorm(Data$n_t,sd=0.01), "Nu_dt"=rmatrix(Data$n_b,Data$n_t,sd=0.01))
if(Version=="OU_GMRF_v1g") Params = list( "log_theta"=log(1), "log_SD"=log(1), "log_theta_st"=log(1), "log_SD_st"=log(1), "rho_st"=0, "log_sigmaIID"=log(1), "log_mean"=log(1), "log_extradetectionSD"=log(1), "rhot"=0, "log_sigmat"=log(1), "gamma_j"=rep(0,ncol(Data$X_ij)), "log_detectrate"=log(0.2), "log_extradetectrate_i"=rnorm(Data$n_i,sd=0.01), "lognormal_overdispersed_i"=rnorm(Data$n_i,sd=0.01), "Epsiloninput_d"=rnorm(Data$n_b,sd=0.01), "Deltainput_t"=rnorm(Data$n_t,sd=0.01), "Nu_dt"=rmatrix(Data$n_b,Data$n_t,sd=0.01))
if(Version%in%c("OU_GMRF_v1a","OU_GMRF_v1b")) Random = c( "Epsiloninput_d" )
if(Version%in%c("OU_GMRF_v1c","OU_GMRF_v1d")) Random = c( "Epsiloninput_d", "log_extradetectrate_i" )
if(Version%in%c("OU_GMRF_v1e")) Random = c( "Epsiloninput_d", "log_extradetectrate_i", "Deltainput_t" )
if(Version%in%c("OU_GMRF_v1f")) Random = c( "Epsiloninput_d", "log_extradetectrate_i", "Deltainput_t", "Nu_dt" )
if(Version%in%c("OU_GMRF_v1g")) Random = c( "Epsiloninput_d", "log_extradetectrate_i", "Deltainput_t", "Nu_dt", "lognormal_overdispersed_i" )
# Turn off random effects if desired
Map = list()
if( Version%in%c("OU_GMRF_v1g","OU_GMRF_v1f","OU_GMRF_v1e","OU_GMRF_v1d") & Options_vec[["SpatialTF"]]==FALSE ){
Map[["log_theta"]] = factor(NA)
Map[["log_SD"]] = factor(NA)
Params[["Epsiloninput_d"]] = rep(0,length(Params[["Epsiloninput_d"]]))
Map[["Epsiloninput_d"]] = factor( rep(NA,length(Params[["Epsiloninput_d"]])) )
}
if( Version%in%c("OU_GMRF_v1g","OU_GMRF_v1f","OU_GMRF_v1e","OU_GMRF_v1d") & Options_vec[["TemporalTF"]]==FALSE ){
Map[["rhot"]] = factor(NA)
Map[["log_sigmat"]] = factor(NA)
Params[["Deltainput_t"]] = rep(0,length(Params[["Deltainput_t"]]))
Map[["Deltainput_t"]] = factor( rep(NA,length(Params[["Deltainput_t"]])) )
}
if( Version%in%c("OU_GMRF_v1g","OU_GMRF_v1f","OU_GMRF_v1e","OU_GMRF_v1d") & Options_vec[["SpatiotemporalTF"]]==FALSE ){
Map[["log_theta_st"]] = factor(NA)
Map[["log_SD_st"]] = factor(NA)
Map[["rho_st"]] = factor(NA)
Params[["Nu_dt"]] = array(0,dim(Params[["Nu_dt"]]))
Map[["Nu_dt"]] = factor( array(NA,dim(Params[["Nu_dt"]])) )
}
if( Version%in%c("OU_GMRF_v1g","OU_GMRF_v1f","OU_GMRF_v1e","OU_GMRF_v1d") & Options_vec[["DetectabilityTF"]]==FALSE ){
Map[["log_extradetectionSD"]] = factor(NA)
Map[["log_extradetectrate_i"]] = factor( rep(NA,Data$n_i) )
Params[["log_extradetectrate_i"]] = rep(0,Data$n_i)
}
input_list <- list(Data = Data, Params = Params, Map = Map, Random = Random)
return(input_list)
} # end input function
Options_vec = c("SpatialTF"=0, "TemporalTF"=0, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj1 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report1 = obj$report()
# First run
obj1$fn( obj1$par )
# Check for parameters that don't do anything
Which = which( obj1$gr( obj1$par )==0 )
# Run model
opt1 = nlminb(start=obj1$env$last.par.best[-c(obj1$env$random)], objective=obj1$fn, gradient=obj1$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
Options_vec = c("SpatialTF"=0, "TemporalTF"=0, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj1 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report1 = obj$report()
Report1 = obj1$report()
# First run
obj1$fn( obj1$par )
# Check for parameters that don't do anything
Which = which( obj1$gr( obj1$par )==0 )
# Run model
opt1 = nlminb(start=obj1$env$last.par.best[-c(obj1$env$random)], objective=obj1$fn, gradient=obj1$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt1[["final_gradient"]] = obj1$gr( opt1$par )
opt1[["AIC"]] = 2*opt1$objective + 2*length(opt1$par)
Options_vec = c("SpatialTF"=0, "TemporalTF"=1, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj2 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj2$report()
# First run
obj2$fn( obj2$par )
# Check for parameters that don't do anything
Which = which( obj2$gr( obj2$par )==0 )
# Run model
opt2 = nlminb(start=obj2$env$last.par.best[-c(obj2$env$random)], objective=obj2$fn, gradient=obj2$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt2[["final_gradient"]] = obj2$gr( opt2$par )
opt2[["AIC"]] = 2*opt2$objective + 2*length(opt2$par)
cbind(c(opt1$AIC, opt2$AIC))
#----------------- Spatial Only ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=0, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj3 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj3$report()
# First run
obj3$fn( obj3$par )
# Check for parameters that don't do anything
Which = which( obj3$gr( obj3$par )==0 )
# Run model
opt3 = nlminb(start=obj3$env$last.par.best[-c(obj3$env$random)], objective=obj3$fn, gradient=obj3$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt3[["final_gradient"]] = obj3$gr( opt3$par )
opt3[["AIC"]] = 2*opt3$objective + 2*length(opt3$par)
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=0, "TemporalTF"=0, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj4 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj4$report()
# First run
obj4$fn( obj4$par )
# Check for parameters that don't do anything
Which = which( obj4$gr( obj4$par )==0 )
# Run model
opt4 = nlminb(start=obj4$env$last.par.best[-c(obj4$env$random)], objective=obj4$fn, gradient=obj4$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt4[["final_gradient"]] = obj4$gr( opt4$par )
opt4[["AIC"]] = 2*opt4$objective + 2*length(opt4$par)
aic_table <- data.frame(cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal"
)
names(aic_table) <- c("Model", "AIC")
aic_table <- data.frame(cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal"
))
)
names(aic_table) <- c("Model", "AIC")
aic_table
c("Obs", "Temporal", "Spatial", "Spatiotemporal", "Temporal + ST", "S+T+ST")
c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC, opt5$AIC, opt6$AIC)
c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC)
cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal", "Temporal + ST", "S+T+ST"), c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC, opt5$AIC, opt6$AIC)
)
cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal"), c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC))
aic_table <- as.data.frame(cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal", "Temporal + ST", "S+T+ST"), c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC, opt5$AIC, opt6$AIC)))
aic_table <- as.data.frame(cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal"), c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC)))
names(aic_table) <- c("Model", "AIC")
aic_table
aic_table <- dplyr::arrange(aic_table, AIC)
aic_table$delta_AIC <- NA
for(i in 2:nrow(aic_table)) {
aic_table$delta_AIC[i] <- aic_table$AIC[i] - aic_table$AIC[i-1]
}
aic_table
aic_table$AIC[i]
aic_table <- as.data.frame(cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal"), c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC)), stringsAsFactors = FALSE)
names(aic_table) <- c("Model", "AIC")
str(aic_table)
aic_table <- as.data.frame(cbind(c("Obs", "Temporal", "Spatial", "Spatiotemporal"), as.numeric(c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC))), stringsAsFactors = FALSE)
names(aic_table) <- c("Model", "AIC")
str(aic_table)
Model <- c("Obs", "Temporal", "Spatial", "Spatiotemporal"
)
AIC <- c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC
)
aic_table <- as.data.frame(Model, AIC, stringsAsFactors = FALSE)
Model
AIC
aic_table <- data.frame(Model, AIC, stringsAsFactors = FALSE)
names(aic_table) <- c("Model", "AIC")
str(aic_table)
aic_table <- dplyr::arrange(aic_table, AIC)
aic_table$delta_AIC <- NA
for(i in 2:nrow(aic_table)) {
aic_table$delta_AIC[i] <- aic_table$AIC[i] - aic_table$AIC[i-1]
}
aic_table
#----------------- Temporal + Spatiotemporal ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=0, "TemporalTF"=1, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj5 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj5$report()
# First run
obj5$fn( obj5$par )
# Check for parameters that don't do anything
Which = which( obj5$gr( obj5$par )==0 )
# Run model
opt5 = nlminb(start=obj5$env$last.par.best[-c(obj5$env$random)], objective=obj5$fn, gradient=obj5$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt5[["final_gradient"]] = obj5$gr( opt5$par )
opt5[["AIC"]] = 2*opt5$objective + 2*length(opt5$par)
#--------------------------------------------------
#----------------- Spatial Temporal Spatiotemporal ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=1, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj6 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj6$report()
# First run
obj6$fn( obj6$par )
# Check for parameters that don't do anything
Which = which( obj6$gr( obj6$par )==0 )
# Run model
opt6 = nlminb(start=obj6$env$last.par.best[-c(obj6$env$random)], objective=obj6$fn, gradient=obj6$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt6[["final_gradient"]] = obj6$gr( opt6$par )
opt6[["AIC"]] = 2*opt6$objective + 2*length(opt6$par)
#--------------------------------------------------
#----------------- Spatial + Temporal ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=1, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj7 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj7$report()
# First run
obj7$fn( obj7$par )
# Check for parameters that don't do anything
Which = which( obj7$gr( obj7$par )==0 )
# Run model
opt7 = nlminb(start=obj7$env$last.par.best[-c(obj7$env$random)], objective=obj7$fn, gradient=obj7$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt7[["final_gradient"]] = obj7$gr( opt7$par )
opt7[["AIC"]] = 2*opt7$objective + 2*length(opt7$par)
#--------------------------------------------------
#--------------- AIC -------------
Model <- c("Obs", "Temporal", "Spatial", "Spatiotemporal", "Temporal + ST", "S+T+ST", "Spatial + Temporal")
AIC <- c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC, opt5$AIC, opt6$AIC, opt7$AIC)
aic_table <- data.frame(Model, AIC, stringsAsFactors = FALSE)
names(aic_table) <- c("Model", "AIC")
aic_table <- dplyr::arrange(aic_table, AIC)
aic_table$delta_AIC <- 0
for(i in 2:nrow(aic_table)) {
aic_table$delta_AIC[i] <- aic_table$AIC[i] - aic_table$AIC[i-1]
}
aic_table
aic_table$delta_AIC <- 0
for(i in 2:nrow(aic_table)) {
aic_table$delta_AIC[i] <- aic_table$AIC[i] - aic_table$AIC[1]
}
aic_table
str(obj6$report)
Report = obj6$report()
str(obj6)
Report = obj6$report()
for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=1, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
Report = obj6$report()
dyn.load( dynlib(paste0("Code/", Version )))
Report = obj6$report()
obj6 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj6$report()
str(Report)
obj6$report
Report = obj6$report( obj6$par )
obj6$par
Report = obj6$report( opt6$par )
# First run
obj6$fn( obj6$par )
# Check for parameters that don't do anything
Which = which( obj6$gr( obj6$par )==0 )
# Run model
opt6 = nlminb(start=obj6$env$last.par.best[-c(obj6$env$random)], objective=obj6$fn, gradient=obj6$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt6[["final_gradient"]] = obj6$gr( opt6$par )
opt6[["AIC"]] = 2*opt6$objective + 2*length(opt6$par)
Report = obj6$report( obj6$par )
Report = obj6$report()
Report6 = obj6$report()
str(Report6)
str(opt4)
# clear environment
rm(list = ls())
gc()
#######################
# Load libraries
#######################
library(TMB)
library(dplyr)
source("Functions/Input_Functions.R")
#######################
# Load data
#######################
load("Data/Prepared_Data_W_Susquehanna.RData")
# remove year from X_ij now so it doesn't mess with testing of temporal and temporal-spatial mdoels
X_ij <- X_ij[ , c("(Intercept)", "length_std", "width_std", "effort_std")]
# df = dataframe with all data including sites with multiple passes (multiple instances of each child)
# family = dataframe with unique child rows. Other columns are parents of each child, lat, lon, and other data associated with each child node.
# C_ip matrix of counts at site-year i on electrofish survey pass p
# X_ij matrix of covariates (j) for each site-year i as a design matrix including the intercept (column of 1s)
# t_i vector of length i indicating the survey year for each site-year visit
# df_stds dataframe with three columns of the parameter name, means, stds used for z-score standardization of the continuously-distributed independent variables in X_ij
#######################
# Fit in TMB
#######################
Version = "OU_GMRF_v1g"
# v1a -- Original version
# v1b -- added covariates matrix X_ij
# v1c- adds linear predictors to SD output and multinomial count process (HAS A BUG!)
# v1d- adds makes random variation in detection probability random, and fixed bug in detectprob calculation
# v1e- adds Temporal variation as AR1 process
# v1f- adds Spatiotemporal variation as kronecker product of O-U and AR1 process, plus interface to turn off components
# v1g- add IID lognormal variation (representing micro-variation)
#setwd( TmbFile )
# Compile
if(FALSE) {
dyn.unload(dynlib(paste0("Code/", Version)))
file.remove( paste0("Code/", Version,c(".o",".dll")) )
}
compile( paste0("Code/", Version,".cpp") )
#----------------- Observation-Detection Only ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=0, "TemporalTF"=0, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj1 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report1 = obj1$report()
# First run
obj1$fn( obj1$par )
# Check for parameters that don't do anything
Which = which( obj1$gr( obj1$par )==0 )
# Run model
opt1 = nlminb(start=obj1$env$last.par.best[-c(obj1$env$random)], objective=obj1$fn, gradient=obj1$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt1[["final_gradient"]] = obj1$gr( opt1$par )
opt1[["AIC"]] = 2*opt1$objective + 2*length(opt1$par)
Report1 = obj1$report()
#--------------------------------------------------
#----------------- Temporal Only ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=0, "TemporalTF"=1, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj2 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj2$report()
# First run
obj2$fn( obj2$par )
# Check for parameters that don't do anything
Which = which( obj2$gr( obj2$par )==0 )
# Run model
opt2 = nlminb(start=obj2$env$last.par.best[-c(obj2$env$random)], objective=obj2$fn, gradient=obj2$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt2[["final_gradient"]] = obj2$gr( opt2$par )
opt2[["AIC"]] = 2*opt2$objective + 2*length(opt2$par)
Report2 = obj2$report()
#--------------------------------------------------
#----------------- Spatial Only ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=0, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj3 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj3$report()
# First run
obj3$fn( obj3$par )
# Check for parameters that don't do anything
Which = which( obj3$gr( obj3$par )==0 )
# Run model
opt3 = nlminb(start=obj3$env$last.par.best[-c(obj3$env$random)], objective=obj3$fn, gradient=obj3$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt3[["final_gradient"]] = obj3$gr( opt3$par )
opt3[["AIC"]] = 2*opt3$objective + 2*length(opt3$par)
Report3 = obj3$report()
#--------------------------------------------------
#----------------- Spatiotemporal Only ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=0, "TemporalTF"=0, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj4 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj4$report()
# First run
obj4$fn( obj4$par )
# Check for parameters that don't do anything
Which = which( obj4$gr( obj4$par )==0 )
# Run model
opt4 = nlminb(start=obj4$env$last.par.best[-c(obj4$env$random)], objective=obj4$fn, gradient=obj4$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt4[["final_gradient"]] = obj4$gr( opt4$par )
opt4[["AIC"]] = 2*opt4$objective + 2*length(opt4$par)
Report4 = obj4$report()
#--------------------------------------------------
#----------------- Temporal + Spatiotemporal ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=0, "TemporalTF"=1, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj5 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj5$report()
# First run
obj5$fn( obj5$par )
# Check for parameters that don't do anything
Which = which( obj5$gr( obj5$par )==0 )
# Run model
opt5 = nlminb(start=obj5$env$last.par.best[-c(obj5$env$random)], objective=obj5$fn, gradient=obj5$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt5[["final_gradient"]] = obj5$gr( opt5$par )
opt5[["AIC"]] = 2*opt5$objective + 2*length(opt5$par)
Report5 = obj5$report()
#--------------------------------------------------
#----------------- Spatial Temporal Spatiotemporal ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=1, "SpatiotemporalTF"=1, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj6 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj6$report()
# First run
obj6$fn( obj6$par )
# Check for parameters that don't do anything
Which = which( obj6$gr( obj6$par )==0 )
# Run model
opt6 = nlminb(start=obj6$env$last.par.best[-c(obj6$env$random)], objective=obj6$fn, gradient=obj6$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt6[["final_gradient"]] = obj6$gr( opt6$par )
opt6[["AIC"]] = 2*opt6$objective + 2*length(opt6$par)
Report6 = obj6$report()
SD6 = sdreport( obj6, bias.correct=TRUE )
#--------------------------------------------------
#----------------- Spatial + Temporal ------------------
# Turn off random effects in v1f (0 means exclude a component, except for ObsModel)
Options_vec = c("SpatialTF"=1, "TemporalTF"=1, "SpatiotemporalTF"=0, "DetectabilityTF"=1, "ObsModel"=1)
# Make inputs
Inputs <- makeInput(family = family, c_i = c_i, options = Options_vec, X = X_ij, t_i = t_i, version = Version)
# Make object
dyn.load( dynlib(paste0("Code/", Version )))
obj7 <- MakeADFun(data=Inputs$Data, parameters=Inputs$Params, random=Inputs$Random, map=Inputs$Map, hessian=FALSE, inner.control=list(maxit=1000) )
Report = obj7$report()
# First run
obj7$fn( obj7$par )
# Check for parameters that don't do anything
Which = which( obj7$gr( obj7$par )==0 )
# Run model
opt7 = nlminb(start=obj7$env$last.par.best[-c(obj7$env$random)], objective=obj7$fn, gradient=obj7$gr, control=list(eval.max=1e4, iter.max=1e4, trace=1, rel.tol=1e-14) )
opt7[["final_gradient"]] = obj7$gr( opt7$par )
opt7[["AIC"]] = 2*opt7$objective + 2*length(opt7$par)
Report7 = obj7$report()
#--------------------------------------------------
#--------------- AIC -------------
Model <- c("Obs", "Temporal", "Spatial", "Spatiotemporal", "Temporal + ST", "S+T+ST", "Spatial + Temporal")
AIC <- c(opt1$AIC, opt2$AIC, opt3$AIC, opt4$AIC, opt5$AIC, opt6$AIC, opt7$AIC)
aic_table <- data.frame(Model, AIC, stringsAsFactors = FALSE)
names(aic_table) <- c("Model", "AIC")
aic_table <- dplyr::arrange(aic_table, AIC)
aic_table$delta_AIC <- 0
for(i in 2:nrow(aic_table)) {
aic_table$delta_AIC[i] <- aic_table$AIC[i] - aic_table$AIC[1]
}
aic_table
str(Report5)
1-exp(-1*1)
exp(-1)
exp(-1)
exp(0)
summary(Report5$rhot)
summary(Report5$rho_t_b)
str(Report6)
str(c_ip)
str(family)
str(X_ij)
str(t_i)
str(df)
df_out <- data.frame(df, Report6$lambda_ip[ , 1], Report5$lambda_ip[ , 1])
unique(df$child_name)
data.frame(df, Report6$lambda_ip[ , 1], Report5$lambda_ip[ , 1]) %>%
dplyr::filter(!grepl("N_", child_name))
df_out <- data.frame(df, Report6$lambda_ip[ , 1], Report5$lambda_ip[ , 1]) %>%
dplyr::filter(!grepl("N_", child_name))
str(df_out)
df_out <- data.frame(df, lambda6 = Report6$lambda_ip[ , 1], lambda5 = Report5$lambda_ip[ , 1]) %>%
dplyr::filter(!grepl("N_", child_name))
library(tidyr)
?spread
df_wide <- spread(df_out, key = child_name, value = lambda5)
str(df_wide)
df_wide <- df_out %>%
dplyr::select(child_name, year, lambda5) %>%
spread(key = c(child_name, year), value = lambda5)
df_out %>%
dplyr::select(child_name, year, lambda5)
df_wide <- df_out %>%
dplyr::select(child_name, year, lambda5) %>%
spread(key = child_name, value = lambda5)
str(df_wide)
df_wide <- df_out %>%
dplyr::select(child_name, year, lambda5) %>%
spread(key = year, value = lambda5)
str(df_wide)
dim(df_out)
df_wide
write.csv(df_wide, file = "Output/predictions_by_year.csv")
